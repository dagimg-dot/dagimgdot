---
export interface Props {
  initialGreeting?: string;
  initialLanguage?: string;
  countryCode?: string;
  detectedLanguages?: string[];
}

const {
  initialGreeting = "ሰላም",
  initialLanguage = "am",
  countryCode = "ET",
  detectedLanguages = ["am-ET"],
} = Astro.props;
---

<span
  class="greeting-text"
  data-initial-greeting={initialGreeting}
  data-initial-language={initialLanguage}
  data-country-code={countryCode}
  data-detected-languages={JSON.stringify(detectedLanguages)}
>
  {initialGreeting}
</span>

<script>
  class TextScramble {
    element: HTMLElement;
    chars: string;
    queue: Array<{
      from: string;
      to: string;
      start: number;
      end: number;
      char?: string;
    }>;
    frame: number;
    frameRequest: number;
    resolve: (() => void) | null;

    constructor(element: HTMLElement) {
      this.element = element;
      this.chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789αβγδεζηθικλμνξοπρστυφχψωΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩሀሁሂሃሄህሆለሉሊላሌልሎሏሐሑሒሓሔሕሖሗመሙሚማሜምሞሟሠሡሢሣሤሥሦሧረሩሪራሬርሮሯሰሱሲሳሴስሶሷሸሹሺሻሼሽሾሿቀቁቂቃቄቅቆቇቈቊቋቌቍቐቑቒቓቔቕቖቘቚቛቜቝበቡቢባቤብቦቧቨቩቪቫቬቭቮቯተቱቲታቴትቶቷቸቹቺቻቼችቾቿኀኁኂኃኄኅኆኇኈኊኋኌኍነኑኒናኔንኖኗኘኙኚኛኜኝኞኟአኡኢኣኤእኦኧከኩኪካኬክኮኯኰ኱ኲኳኴኵኸኹኺኻኼኽኾዀ዁ዂዃዄዅወዉዊዋዌውዎዏዐዑዒዓዔዕዖዘዙዚዛዜዝዞዟዠዡዢዣዤዥዦዧየዩዪያዬይዮዯደዱዲዳዴድዶዷዸዹዺዻዼዽዾዿጀጁጂጃጄጅጆጇገጉጊጋጌግጎጏጐ጑ጒጓጔጕጘጙጚጛጜጝጞጟጠጡጢጣጤጥጦጧጨጩጪጫጬጭጮጯጰጱጲጳጴጵጶጷጸጹጺጻጼጽጾጿፀፁፂፃፄፅፆፇፈፉፊፋፌፍፎፏፐፑፒፓፔፕፖፗፘፙፚ፟፠፡።፣፤፥፦፧፨፩፪፫፬፭፮፯፰፱፲፳፴፵፶፷፸፹፺፻፼";
      this.queue = [];
      this.frame = 0;
      this.frameRequest = 0;
      this.resolve = null;
      this.update = this.update.bind(this);
    }

    setText(newText: string): Promise<void> {
      const oldText = this.element.innerText;
      const length = Math.max(oldText.length, newText.length);
      const promise = new Promise<void>((resolve) => (this.resolve = resolve));
      this.queue = [];

      // Add scrambling class for blur effect
      this.element.classList.add("scrambling");

      for (let i = 0; i < length; i++) {
        const from = oldText[i] || "";
        const to = newText[i] || "";
        const start = Math.floor(Math.random() * 8);
        const end = start + Math.floor(Math.random() * 12) + 15;
        this.queue.push({ from, to, start, end });
      }

      cancelAnimationFrame(this.frameRequest);
      this.frame = 0;
      this.update();
      return promise;
    }

    update(): void {
      let output = "";
      let complete = 0;

      for (let i = 0, n = this.queue.length; i < n; i++) {
        let { from, to, start, end, char } = this.queue[i];

        if (this.frame >= end) {
          complete++;
          output += to;
        } else if (this.frame >= start) {
          if (!char || Math.random() < 0.4) {
            char = this.randomChar();
            this.queue[i].char = char;
          }
          output += char;
        } else {
          output += from;
        }
      }

      this.element.innerText = output;

      if (complete === this.queue.length) {
        // Remove scrambling class when animation is complete
        this.element.classList.remove("scrambling");
        if (this.resolve) {
          this.resolve();
        }
      } else {
        this.frameRequest = requestAnimationFrame(this.update);
        this.frame++;
      }
    }

    randomChar(): string {
      return this.chars[Math.floor(Math.random() * this.chars.length)];
    }
  }

  // Import client-side translation utility
  async function translateText(
    text: string,
    targetLang: string,
    sourceLang: string = "en"
  ): Promise<string> {
    try {
      const { translateText: clientTranslate } = await import(
        "../utils/clientTranslation.ts"
      );
      return await clientTranslate(text, targetLang, sourceLang);
    } catch (error) {
      console.error("Client translation error:", error);
      return text;
    }
  }

  function getNextLanguage(
    currentLang: string,
    availableLangs: string[]
  ): string {
    // Ensure we have languages to cycle through
    if (!availableLangs || availableLangs.length === 0) {
      return "en";
    }

    // Get base language codes (remove country codes like 'en-US' -> 'en')
    const baseLangs = availableLangs.map((lang) => lang.split("-")[0]);

    // Find current language index
    const currentIndex = baseLangs.indexOf(currentLang);

    // If current language not found, start from the beginning
    const startIndex = currentIndex === -1 ? 0 : currentIndex;
    const nextIndex = (startIndex + 1) % baseLangs.length;

    return baseLangs[nextIndex];
  }

  // Wait for page to load
  document.addEventListener("DOMContentLoaded", async () => {
    const greetingElement = document.querySelector(
      ".greeting-text"
    ) as HTMLElement;

    if (greetingElement) {
      const fx = new TextScramble(greetingElement);
      const initialLanguage = greetingElement.getAttribute(
        "data-initial-language"
      );
      const detectedLanguages = JSON.parse(
        greetingElement.getAttribute("data-detected-languages") || "[]"
      );

      let currentLanguage = initialLanguage;
      let isAnimating = false;

      // Toggle between languages on hover
      greetingElement.addEventListener("mouseenter", async () => {
        if (!isAnimating && detectedLanguages && detectedLanguages.length > 1) {
          isAnimating = true;

          try {
            // Get the next language to switch to
            const nextLanguage = getNextLanguage(
              currentLanguage || "en",
              detectedLanguages
            );

            console.log(`Cycling from ${currentLanguage} to ${nextLanguage}`);

            const nextGreeting = await translateText(
              "Hello",
              nextLanguage,
              "en"
            );

            console.log(`Translated greeting: ${nextGreeting}`);

            fx.setText(nextGreeting).then(() => {
              currentLanguage = nextLanguage;
              isAnimating = false;
            });
          } catch (error) {
            console.error("Translation failed:", error);
            isAnimating = false;
          }
        } else if (detectedLanguages && detectedLanguages.length <= 1) {
          console.log("Only one language available, no cycling needed");
        }
      });
    }
  });
</script>

<style>
  .greeting-text {
    cursor: pointer;
    transition: all 2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    display: inline-block;
  }

  .greeting-text:hover {
    color: #3b82f6;
    transform: scale(1.05);
  }

  .greeting-text.scrambling {
    filter: blur(1.5px);
    animation: scramble-blur 0.06s infinite alternate;
  }

  @keyframes scramble-blur {
    0% {
      filter: blur(1.2px);
    }
    100% {
      filter: blur(2px);
    }
  }
</style>
